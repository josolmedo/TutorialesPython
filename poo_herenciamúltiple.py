# -*- coding: utf-8 -*-
"""POO_HerenciaMúltiple.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cdyFdteJePyTqXqF-pRlVdEaB4MZQVNS
"""

'''Encapsulamiento de todos las atributos de mi clase'''
class Persona:
  def __init__(self, nombre, apellido, edad):
    self._nombre=nombre #Se le agrega un guión bajo para decir que lo encapsule
    self._apellido=apellido
    self._edad=edad

  #Un decorador modifica el comportamiento de nuestro método
  #Método GET
  @property #Permite acceder al método como si llamara al atributo
  def nombre(self):
    print('Llamando método GET nombre')
    return self._nombre

  #Método SET
  @nombre.setter #Decorador para poder modificar el atributo del nombre
  def nombre(self, nombre):
    print('Llamando método SET nombre')
    self._nombre=nombre

  #Metodo GET
  @property
  def apellido(self):
    print("Llamando método GET apellido")
    return self._apellido

  #Método SET
  @apellido.setter
  def apellido(self, apellido):
    print("LLamando método SET apellido")
    self._apellido=apellido

  #Método GET
  @property
  def edad(self):
    print("Llamando método GET edad")
    return self._edad

  #Método SET
  @edad.setter
  def edad(self, edad):
    print("Llamando método SET edad")
    self._edad=edad

  def mostrar_detalle(self):
    print(f'Persona: {self._nombre}, {self._apellido} {self._edad}')

  def __str__(self): #Permitirá imprimir todos los detalles de un objeto de esta clase haciendo print(persona1)
    return f'Persona: {self._nombre} {self._apellido} {self._edad}'

  def __del__(self):
    print(f'Persona: {self._nombre} {self._apellido} eliminado')

persona1=Persona('José', 'Olmedo', 23)
persona1.nombre='Marco Isaac'#Así podemos modificar el atributo "nombre" empleando un método que permite acceder al atributo
print('\n')

persona1.apellido='Olmedo Guevara'
persona1.edad=30
persona1.mostrar_detalle()

"""Ejercicio de generar una clase vehículo y dos clases hijas.

"""

class FiguraGeometrica(object):

  def __init__(self, ancho, alto):
    if self._validar_valor(ancho):
      self._ancho=ancho
    else:
      print("Ingresaste un valor negativo, se trabajará con un valor 0")
      self._ancho=0
    if self._validar_valor(alto):
      self._alto=alto
    else:
      print("Ingresaste un valor negativo, se trabajará con un valor 0")
      self._alto=0

  @property #Método GET
  def ancho(self):
    print("Llamando método GET ancho")
    return self._ancho

  @ancho.setter #Método SET
  def ancho(self, ancho):
    print("Llamando método SET ancho")
    self._ancho=ancho

  @property #Método GET
  def alto(self):
    print("Llamando método GET alto")
    return self._alto

  @alto.setter #Método SET
  def alto(self, alto):
    print("Llamando método SET alto")
    self._alto=alto

  def _validar_valor(self,valor): #Este método es interno, para evitar que se ingresen números negativos
    return True if valor>0 else False

  def __str__(self):
    return f'Figura geométrica de ancho: {self._ancho} y alto de: {self._alto} unidades'

class Color(object):

  def __init__(self, color):
    self._color=color

  @property #Método GET
  def color(self):
    print("Llamando al metodo GET color")
    return self._color

  @color.setter #Método SET
  def color(self, color):
    print('Llamando al método SET color')
    self._color=color

  def __str__(self):
    return f'Color {self._color}'

class Cuadrado(FiguraGeometrica, Color):

  def __init__(self, lado, color):
    self._lado=lado
    self._color=color
    # super().__init__(color) Cuando es herencia múltiple, hay que evitar esta sintaxis
    FiguraGeometrica.__init__(self, lado, lado) #Así ya inicializamos los atributos de la clase padre
    Color.__init__(self, color) #Inicializamos la segunda clase padre.

  def calcular_area(self):
    area=self._ancho*self._alto #Accedemos a los atributos de la clase padre FiguraGeometrica
    return f'El área es de: {area}' #Imprimimos el área

  @property #Método GET
  def lado(self):
    print("Llamando al método GET lado")
    return self._lado

  @lado.setter #Método SET
  def lado(self, lado):
    print('Llamando al método SET lado')
    self._lado=lado

  @property #Método GET
  def color(self):
    print("Llamando al método GET color")
    return self._color

  @lado.setter #Método SET
  def color(self, color):
    print('Llamando al método SET color')
    self._color=color

  def __str__(self):
    return f'Cuadrado de lado de {self._lado} unidades y de color {self._color}'

class Rectangulo(FiguraGeometrica, Color):

  def __init__(self, alto, ancho, color):
    self._ancho=ancho
    self._alto=alto
    self._color=color
    FiguraGeometrica.__init__(self, ancho, alto) #Así ya inicializamos los atributos de la clase padre
    Color.__init__(self, color) #Inicializamos la segunda clase padre.

  @property #Método GET
  def ancho(self):
    print("Llamando método GET ancho")
    return self._ancho

  @ancho.setter #Método SET
  def ancho(self, ancho):
    print("Llamando método SET ancho")
    self._ancho=ancho

  @property #Método GET
  def alto(self):
    print("Llamando método GET alto")
    return self._alto

  @alto.setter #Método SET
  def alto(self, alto):
    print("Llamando método SET alto")
    self._alto=alto

  def calcular_area(self):
    area=self._ancho*self._alto
    self._area=area
    return f'Área de: {self._area} unidades cuadradas' #Imprimimos el área.

  def __str__(self):
    return f'Rectangulo de ancho {self._ancho} y de alto {self._alto} unidades con color {self._color}'

cuadrado1=Cuadrado(23,'Azul')
rectangulo1=Rectangulo(5,6,'Verde')
print(cuadrado1)
print(rectangulo1)
print(cuadrado1.ancho)
print(cuadrado1.lado)
print(rectangulo1.alto)
print(rectangulo1.color)
print('\n')
print(cuadrado1.calcular_area())
print(rectangulo1.calcular_area())

#Método MRO - Method Resolution Order
print(Cuadrado.mro())

